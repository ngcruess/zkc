package zk

import (
	"fmt"
	"time"
)

type Zettel struct {
	Address            `json:"address"`
	Body               string              `json:"body"`
	References         string              `json:"references"`
	CreatedAt          time.Time           `json:"created_at"`
	UpdatedAt          time.Time           `json:"updated_at"`
	Parent             *Zettel             `json:"parent"`
	Children           map[Address]*Zettel `json:"children"`
	Related            []Address           `json:"related"`
	LatestChildAddress Address             `json:"latest_child_address"`
}

// `AddChildWithAddress` adds a child to a Zettel, making sure the specified Address is not already occupied
// This is where the uniqueness of Addresses within a collection is enforced.
// Returns:
// 	- error if the Address of the given Zettel is not unique, or `nil`
func (z *Zettel) AddChildWithAddress(zettel *Zettel) error {
	if z.Children == nil {
		z.Children = map[Address]*Zettel{
			zettel.Address: zettel,
		}
	} else {
		if _, ok := z.Children[zettel.Address]; ok {
			return fmt.Errorf("zettel already exists with address %v", zettel.Address)
		}
		z.Children[zettel.Address] = zettel
	}
	return nil
}

// `NewChild` creates a Zettel and adds it to the Children of the receiving Zettel.
// The Address of the new Zettel is generated by incrementing the latestChildAddress (see `Address.Increment`)
// Returns:
// 	- error if the Address of the given Zettel is not unique, or `nil`
func (z *Zettel) NewChild(body string, references string, related ...Address) (*Zettel, error) {
	address := z.LatestChildAddress.Increment()
	newZ := z.NewZettel(address, body, references, related...)
	err := z.AddChildWithAddress(newZ)
	if err != nil {
		return nil, err
	}
	return newZ, nil
}

// `NewZettel` creates a new Zettel with the given Address and body, automatically
// setting the `CreatedAt` and `UpdatedAt` values to the current time in the
// current time zone. This is a method rather than a function to enforce the
// doubly-linked semantics. The only way to have a Zettel without a Parent is to
// create one directly, which will only be done in tests and for the global parent.
// Returns:
// 	- a pointer to the new Zettel
func (z *Zettel) NewZettel(address Address, body string, references string, related ...Address) *Zettel {
	newZ := Zettel{
		Address:            address,
		Body:               body,
		References:         references,
		CreatedAt:          time.Now(),
		UpdatedAt:          time.Now(),
		Related:            related,
		LatestChildAddress: address,
		Parent:             z,
	}
	z.LatestChildAddress = address
	return &newZ
}

// `AddDescendent` uses the Address of the given Zettel to insert it into the correct place
// in the tree.
// Returns:
// 	- error if the Address of the given Zettel is invalid or `nil`
func (z *Zettel) AddDescendent(cur *Zettel, depth int, newZ *Zettel) error {
	addr, err := newZ.Address.AncestorAtDepth(depth)
	// This is only possible if the specified starting depth exceeds the address depth
	if err != nil {
		return err
	}
	if *addr == newZ.Address {
		return cur.AddChildWithAddress(newZ)
	}
	if inner, ok := cur.Children[*addr]; ok {
		return z.AddDescendent(inner, depth+1, newZ)
	}
	return fmt.Errorf("invalid address for new zettel: %s", newZ.Address)
}

// `GetDescendentByAddress` uses the `Ancestry` of the given Address to
// navigate the tree of the receiver Zettel, finding the Zettel with the matching Address.
// Returns:
//	- pointer to the matching Zettel if it is found, or `nil` if not
//	- error if the given address does not match a Zettel, or `nil` if the Zettel was found
func (z *Zettel) GetDescendentByAddress(address Address) (*Zettel, error) {
	if address == z.Address {
		return z, nil
	}
	descendent := z
	for _, ancestor := range address.Ancestry() {
		if c, ok := descendent.Children[ancestor]; ok {
			descendent = c
		} else {
			return nil, fmt.Errorf("address '%v' not found", address)
		}
	}
	return descendent, nil
}
